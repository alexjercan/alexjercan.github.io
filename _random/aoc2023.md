---
title: Advent of Code 2023
layout: post
tags: [haskell, linux, aoc]
date: 30 Nov 2023
comments: true
---

# About

[Advent of Code 2023](https://adventofcode.com/2023) in Haskell. Follow the
development of this on <https://github.com/alexjercan/aoc-2023>. This blog post
will contain my notes on solving each day and explanations for the solutions.

# Quickstart

To download the puzzle inputs, copy the `.env.example` file into `.env` and
fill in the session with your cookie from the aoc website. Then you can run

```console
./get
```

To run one day in particular you can run

```console
make Day%
```

where `%` is the day number with 2 digits (01, 02, ... 20, 21)

For more information on the usage you can also check out the github repository.

# Solutions

I will solve each day of AoC in Haskell and post each one on this page.

{% include christmas/tree.html %}

**Day 1** - For the first part it is enough to scan trough all the characters
and choose which ones are digits. Then you just need the first and the last.
Combine them into the numbers and add them. But for the second part you also
need to find digits made up of strings, which is more difficult. To be fair, I
think that this first day of AoC was harder than previous years, but it was
still a fun problem. My idea was to generate all the suffixes of the string and
find what digit, if any, starts in the beginning of it. So basically I just
generated all the digits, as before, but took into account the names too. Then
I took the first one and the last one and did the same as for part 1. But I
struggled to implement this idea in Haskell, because I was using the `tails`
and `isInfixOf` functions wrong. I tought that tails generates the tail of the
list in the same way as inits does, and starts from the empty list, but it
actually goes the other way around. I found this out after like 20 minutes of
banging my head againts the wall, but it is what it is. Then I tought that
`isInfixOf` only matches the start of the string, but I should have used
`isPrefixOf`. Small mistake, I blame ChatGPT for that. Anyway, while working
for the solution for the second part, I realized that you can also solve part 1
with the same approach, but you just ignore the digit names. So yeah, my final
solution is just changing up this `tryToDigit` function depending on which part
you need to solve.

{% include christmas/present.html %}

**Day 2** - Parsing... I kind of forgot how to do it, so I had to check my old
AoC in Haskell and steal it from there. But I am surprised I still remember a
lot of helper functions from parsec. Anyway, my idea was to create a small data
structure called `Game` that will hold the index and a list of `Round`s. The
round will be the RGB colors of the cubes. So I basically started with parsing
from the smallest block and then made my way up to the entire input. You can
go both ways, but I find it easier like this because of whitespaces. I want the
whitespaces to be dealt with in the higher level blocks. After we get the data
structure to parse it is really simple. We just need to check each color of the
round to be bounded by the numbers in the statement and we get the valid games.
Then for the second part, we just had to see what is the minimum number of
cubes required for each game to be able to be played. So we just need to look
for the maximum number in each game and that would be the bare minimum. So
yeah, took me 30 minutes to solve, but most of the time I spent on parsing, you
can also see that from the time it took to solve part 2 after part 1.

{% include christmas/elf.html %}

**Day 3** - Matrices... I always find them annoying in Haskell. However, I
don't think I have found myself in any rabit hole... it was a straightforward
solution. My idea was to go trough all the characters on the map, parse all the
numbers, then filter just the numbers that have an adjacent symbol and sum
them. For part 2 I also kept the position and the character of the symbol, then
filtered only gears and then used a hashmap to figure out which gears have 2
numbers (a hashmap from the position of the gear to the numbers that are next
to it) and then did the product and sum. It took me longer to solve just
because there was a lot more code to write. And in between the first part and
second one I took a short break. But I wouldn't say that this problem was hard.
All I can say is that it could have been worse. I liked how I managed to have a
really similar solution for both parts.
